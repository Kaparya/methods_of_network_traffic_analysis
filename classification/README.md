# Классификация уровня IT-специалистов

Этот проект — Proof of Concept (PoC) для задачи автоматического определения грейда IT-специалиста (**Junior / Middle / Senior**) на основе данных из резюме (датасет hh.ru).

Основная цель: проверить гипотезу, можно ли по косвенным признакам (зарплата, возраст, город, образование, тип занятости и др.) предсказать уровень квалификации, **не используя** при обучении те признаки, по которым производилась разметка (название должности и стаж работы), чтобы избежать утечки целевой переменной.

## Результаты

Модель обучена на ~24 000 сэмплах и протестирована на отложенной выборке (6 000 резюме).

| Метрика | Значение | Комментарий |
|---------|----------|-------------|
| **Accuracy** | **0.75** | Модель верно определяет грейд в 75% случаев |
| **F1 (Senior)** | **0.86** | Сеньоры определяются очень точно |
| **F1 (Junior)** | **0.56** | Джуны часто путаются с Мидлами |
| **F1 (Middle)** | **0.56** | Мидлы — самый сложный для разделения класс |

**Ключевые факторы (Top Features):**
1. **Возраст (38%)**: Сильнейший косвенный признак опыта.
2. **Зарплата (17%)**: Четко коррелирует с уровнем ответственности.
3. **Месяц рождения (9%)**: Вероятно, шумовой признак или артефакт данных.
4. **Наличие авто (5%)**: Косвенный признак дохода/возраста.

### Почему метрики для Junior/Middle невысокие (F1 ~0.56)?
1. **Синтетическая разметка**: Целевая переменная создана эвристически (правила на основе должности и опыта), а не реальными HR. Модель учит наши правила, а не реальность.
2. **Дисбаланс классов**: Модель отлично научилась угадывать мажоритарный класс. Возможно примеров джунов не хватило (12%)
3. **Шумовые признаки**: Появление "месяца рождения" в топе факторов говорит о нехватке сильных сигналов.
4. **Размытость класса Middle**: Этот класс сложнее всего отделить от опытных Junior или бюджетных Senior без анализа стека технологий.



## Как это работает

Пайплайн обработки данных построен на паттерне **Chain of Responsibility**. Данные проходят через цепочку обработчиков (handlers), каждый из которых выполняет свою задачу:

1. **Filtering**: Отбираются только IT-специалисты (по ключевым словам `developer`, `qa`, `devops`, `python` и др.).
2. **Parsing**: Из сырых текстовых полей извлекаются признаки (возраст, город, зарплата в рублях, график работы).
3. **Labeling (Разметка)**:
   - Грейд проставляется на основе **названия должности** (ключевые слова `senior`, `junior`, `lead`) и **опыта работы** (пороги < 1.5 года / 1.5–5 лет / > 5 лет).
   - **Важно:** Сразу после разметки столбцы `название должности`, `опыт работы` и `предыдущая должность` **удаляются** из датасета. Модель их не видит. Таким образом боремся с target leak.
4. **Encoding**: Категориальные признаки кодируются (One-Hot Encoding).
5. **Training**: Обучается градиентный бустинг **CatBoostClassifier** (300 итераций, `auto_class_weights='Balanced'`).

## Структура проекта

```
classification/
├── src/
│   ├── core.py             # Базовые классы (PipelineContext, Handler)
│   └── handlers/           # Логика обработки данных
│       ├── filtering.py    # Фильтр IT-вакансий
│       ├── labeling.py     # Логика разметки Junior/Middle/Senior
│       ├── parsing.py      # Парсеры (возраст, зарплата, город...)
│       ├── preprocessing.py# Кодирование признаков и сплит
│       └── io.py           # Загрузка/сохранение
├── poc_script.py           # Основной скрипт запуска (pipeline + обучение + отчет)
├── grade_distribution.png  # График распределения классов
└── classification_report.txt # Детальный отчет о метриках
```

## Запуск

Для запуска требуется Python 3.9+ и установленные зависимости (`catboost`, `scikit-learn`, `pandas`, `numpy`, `matplotlib`).

1. Перейдите в папку проекта и запустите скрипт:
   ```bash
   cd classification
   python3 poc_script.py
   ```

Скрипт автоматически:
- Найдет `hh.csv`.
- Проведет очистку и разметку данных.
- Обучит модель.
- Сохранит график распределения (`grade_distribution.png`) и отчет (`classification_report.txt`).

## Вывод

Proof of Concept показал, что **автоматическая классификация грейда возможна** даже без прямых данных об опыте работы и названии должности.

- **Senior** выделяется очень уверенно (точность >90%).
- Разделение **Junior** и **Middle** затруднено без явного указания стажа, так как косвенные признаки (возраст, образование, город) у них часто пересекаются.
- Гипотеза подтверждена: по "вторичным" признакам резюме можно восстановить квалификацию специалиста с разумной точностью (75%), что достаточно для задач первичного скрининга или аналитики рынка.


