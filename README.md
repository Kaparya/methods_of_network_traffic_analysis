# Классификация уровня IT-специалистов

Этот проект — Proof of Concept (PoC) для задачи автоматического определения грейда IT-специалиста (**Junior / Middle / Senior**) на основе данных из резюме (датасет hh.ru).

Основная цель: проверить гипотезу, можно ли по косвенным признакам (зарплата, возраст, город, образование, описание опыта и др.) предсказать уровень квалификации, **не используя** при обучении те признаки, по которым производилась разметка (название должности и числовой стаж работы), чтобы избежать прямой утечки целевой переменной.

## Результаты

Модель обучена на ~24 000 сэмплах и протестирована на отложенной выборке (~6 000 резюме).
В пайплайн была добавлена **NLP-обработка** текстового описания опыта (TF-IDF), что существенно улучшило метрики.

| Метрика | Значение | Комментарий |
|---------|----------|-------------|
| **Accuracy** | **0.88** | Модель верно определяет грейд в 88% случаев |
| **F1 (Senior)** | **0.94** | Сеньоры определяются практически безошибочно |
| **F1 (Junior)** | **0.79** | Отличный результат для самого малочисленного класса |
| **F1 (Middle)** | **0.77** | Уверенное разделение мидлов от джунов и сеньоров |

**Ключевые факторы (Top Features):**
1. **NLP признаки ("лет", "года")**: Слова, указывающие на длительность опыта в тексте (важно! Это не пересекается с данными по которым мы получали таргет).
2. **Возраст**: Сильнейший косвенный демографический признак.
3. **Зарплата**: Четко коррелирует с уровнем ответственности.
4. **Временные маркеры (2018, 2017)**: Упоминание давних лет в опыте работы коррелирует с Senior грейдом.
5. **Город**: Москва и крупные центры чаще коррелируют с высокими грейдами.

### Сложности и ограничения (почему не 100%?)
1. **Синтетическая разметка**: Целевая переменная (`target`) формируется на основе эвристических правил (должность + стаж), а не экспертной оценки HR. В пограничных случаях (например, "Strong Junior" vs "Middle") эвристика может ошибаться, а модель может находить более сложные паттерны, которые формально считаются ошибкой относительно "шумной" разметки.
2. **Размытость границ классов**: Грейд "Middle" является переходным и наименее формализованным. Его сложнее всего отделить от опытного Junior или начинающего Senior, опираясь только на текст резюме без технического собеседования.
3. **Отсутствие выделенного стека технологий**: В текущей реализации мы анализируем общее описание опыта ("О себе"), но не используем специализированное выделение навыков (Python, Java, Kubernetes и т.д.), что могло бы уточнить квалификацию.
4. **Косвенность признаков**: Мы намеренно убрали прямой признак стажа (число месяцев), заставив модель восстанавливать его через контекст (NLP). Это усложняет задачу, но делает решение честным и применимым в реальных сценариях, где стаж может быть не указан явно или указан некорректно.

### Анализ улучшений
После добавления **TF-IDF векторизации** (50 признаков) для колонки с описанием опыта ("О себе/Опыт"), качество модели резко выросло (Accuracy +13%, F1 Junior +23%).
Это подтверждает гипотезу, что даже удалив явное числовое поле "Опыт работы" (чтобы избежать утечки при разметке), модель способна "прочитать" опыт из текста резюме, ориентируясь на контекстные слова и даты.

## Как это работает

Пайплайн обработки данных построен на паттерне **Chain of Responsibility**. Данные проходят через цепочку обработчиков (handlers):

1. **Filtering**: Отбираются только IT-специалисты.
2. **Parsing**: Извлекаются структурированные признаки (возраст, город, зарплата).
3. **NLP Processing**: Текстовое описание опыта преобразуется в TF-IDF векторы.
4. **Labeling (Разметка)**:
   - Грейд проставляется эвристически на основе **названия должности** и **числового опыта**.
   - **Важно:** Сразу после разметки столбцы, использованные для лейблинга, **удаляются**. Модель учится предсказывать грейд только по косвенным признакам и тексту описания.
5. **Encoding**: One-Hot Encoding для категорий.
6. **Training**: **CatBoostClassifier** на сбалансированных весах классов.

## Структура проекта

```
classification/
├── src/
│   ├── core.py             # Базовые классы (PipelineContext, Handler)
│   ├── pipeline.py         # Сборка пайплайна
│   └── handlers/           # Логика обработки данных
│       ├── filtering.py    # Фильтр IT-вакансий
│       ├── labeling.py     # Логика разметки Junior/Middle/Senior
│       ├── parsing.py      # Парсеры и NLP
│       ├── preprocessing.py# Кодирование и сплит
│       └── io.py           # Загрузка/сохранение
├── poc_script.py           # Основной скрипт запуска
├── grade_distribution.png  # График распределения классов
└── classification_report.txt # Детальный отчет
```

## Запуск

Для запуска требуется Python 3.9+ и установленные зависимости (`catboost`, `scikit-learn`, `pandas`, `numpy`, `matplotlib`).

1. Перейдите в папку проекта и запустите скрипт:
   ```bash
   python3 poc_script.py
   ```

Скрипт автоматически:
- Найдет `hh.csv`.
- Проведет очистку и разметку данных.
- Обучит модель.
- Сохранит график распределения (`grade_distribution.png`) и отчет (`classification_report.txt`).

## Вывод

PoC успешен. Автоматическая классификация грейда возможна с высокой точностью (**88%**). Добавление NLP-анализа текста резюме стало ключевым фактором успеха, позволив модели извлекать информацию об опыте из неструктурированного описания, компенсируя отсутствие явного числового поля стажа.
